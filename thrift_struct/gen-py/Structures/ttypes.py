#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class MessageType:
  CREATE = 0
  CONFIGURE = 1
  REQUEST = 2
  RELEASE = 3
  INFORM = 4

  _VALUES_TO_NAMES = {
    0: "CREATE",
    1: "CONFIGURE",
    2: "REQUEST",
    3: "RELEASE",
    4: "INFORM",
  }

  _NAMES_TO_VALUES = {
    "CREATE": 0,
    "CONFIGURE": 1,
    "REQUEST": 2,
    "RELEASE": 3,
    "INFORM": 4,
  }

class ConfigType:
  SUBSCRIBE = 0
  SET_STATE = 1
  ASSIGN_NAME = 2
  CHANGE_PARAMETER = 3

  _VALUES_TO_NAMES = {
    0: "SUBSCRIBE",
    1: "SET_STATE",
    2: "ASSIGN_NAME",
    3: "CHANGE_PARAMETER",
  }

  _NAMES_TO_VALUES = {
    "SUBSCRIBE": 0,
    "SET_STATE": 1,
    "ASSIGN_NAME": 2,
    "CHANGE_PARAMETER": 3,
  }

class InformType:
  CREATION_OK = 0
  CREATION_FAILED = 1
  STATUS = 2
  NEGOTIATE = 3
  REGISTER = 4
  RELEASED = 5
  ERROR = 6
  WARN = 7

  _VALUES_TO_NAMES = {
    0: "CREATION_OK",
    1: "CREATION_FAILED",
    2: "STATUS",
    3: "NEGOTIATE",
    4: "REGISTER",
    5: "RELEASED",
    6: "ERROR",
    7: "WARN",
  }

  _NAMES_TO_VALUES = {
    "CREATION_OK": 0,
    "CREATION_FAILED": 1,
    "STATUS": 2,
    "NEGOTIATE": 3,
    "REGISTER": 4,
    "RELEASED": 5,
    "ERROR": 6,
    "WARN": 7,
  }


class Parameter:
  """
  Attributes:
   - name
   - cmd
   - type
   - default_value
   - mandatory
   - order
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'cmd', None, None, ), # 2
    (3, TType.STRING, 'type', None, None, ), # 3
    (4, TType.STRING, 'default_value', None, None, ), # 4
    (5, TType.BOOL, 'mandatory', None, False, ), # 5
    (6, TType.I16, 'order', None, None, ), # 6
  )

  def __init__(self, name=None, cmd=None, type=None, default_value=None, mandatory=thrift_spec[5][4], order=None,):
    self.name = name
    self.cmd = cmd
    self.type = type
    self.default_value = default_value
    self.mandatory = mandatory
    self.order = order

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.cmd = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.default_value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.mandatory = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I16:
          self.order = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Parameter')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.cmd is not None:
      oprot.writeFieldBegin('cmd', TType.STRING, 2)
      oprot.writeString(self.cmd)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 3)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.default_value is not None:
      oprot.writeFieldBegin('default_value', TType.STRING, 4)
      oprot.writeString(self.default_value)
      oprot.writeFieldEnd()
    if self.mandatory is not None:
      oprot.writeFieldBegin('mandatory', TType.BOOL, 5)
      oprot.writeBool(self.mandatory)
      oprot.writeFieldEnd()
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I16, 6)
      oprot.writeI16(self.order)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.cmd)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.default_value)
    value = (value * 31) ^ hash(self.mandatory)
    value = (value * 31) ^ hash(self.order)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class App:
  """
  Attributes:
   - ap_name
   - binary_path
   - parameters
   - pkg_opkg
   - pkg_tarball
   - tarball_installdir
   - force_tarball_install
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ap_name', None, None, ), # 1
    (2, TType.STRING, 'binary_path', None, None, ), # 2
    (3, TType.LIST, 'parameters', (TType.STRUCT,(Parameter, Parameter.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'pkg_opkg', None, None, ), # 4
    (5, TType.STRING, 'pkg_tarball', None, None, ), # 5
    (6, TType.STRING, 'tarball_installdir', None, None, ), # 6
    (7, TType.BOOL, 'force_tarball_install', None, None, ), # 7
    (8, TType.STRING, 'description', None, None, ), # 8
  )

  def __init__(self, ap_name=None, binary_path=None, parameters=None, pkg_opkg=None, pkg_tarball=None, tarball_installdir=None, force_tarball_install=None, description=None,):
    self.ap_name = ap_name
    self.binary_path = binary_path
    self.parameters = parameters
    self.pkg_opkg = pkg_opkg
    self.pkg_tarball = pkg_tarball
    self.tarball_installdir = tarball_installdir
    self.force_tarball_install = force_tarball_install
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ap_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.binary_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.parameters = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = Parameter()
            _elem5.read(iprot)
            self.parameters.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.pkg_opkg = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.pkg_tarball = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.tarball_installdir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.force_tarball_install = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('App')
    if self.ap_name is not None:
      oprot.writeFieldBegin('ap_name', TType.STRING, 1)
      oprot.writeString(self.ap_name)
      oprot.writeFieldEnd()
    if self.binary_path is not None:
      oprot.writeFieldBegin('binary_path', TType.STRING, 2)
      oprot.writeString(self.binary_path)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.parameters))
      for iter6 in self.parameters:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.pkg_opkg is not None:
      oprot.writeFieldBegin('pkg_opkg', TType.STRING, 4)
      oprot.writeString(self.pkg_opkg)
      oprot.writeFieldEnd()
    if self.pkg_tarball is not None:
      oprot.writeFieldBegin('pkg_tarball', TType.STRING, 5)
      oprot.writeString(self.pkg_tarball)
      oprot.writeFieldEnd()
    if self.tarball_installdir is not None:
      oprot.writeFieldBegin('tarball_installdir', TType.STRING, 6)
      oprot.writeString(self.tarball_installdir)
      oprot.writeFieldEnd()
    if self.force_tarball_install is not None:
      oprot.writeFieldBegin('force_tarball_install', TType.BOOL, 7)
      oprot.writeBool(self.force_tarball_install)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 8)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ap_name)
    value = (value * 31) ^ hash(self.binary_path)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.pkg_opkg)
    value = (value * 31) ^ hash(self.pkg_tarball)
    value = (value * 31) ^ hash(self.tarball_installdir)
    value = (value * 31) ^ hash(self.force_tarball_install)
    value = (value * 31) ^ hash(self.description)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AppInstance:
  """
  Attributes:
   - inst_name
   - app_name
   - arguments
   - environment
   - clean_env
   - map_err_to_out
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'inst_name', None, None, ), # 1
    (2, TType.STRING, 'app_name', None, None, ), # 2
    (3, TType.MAP, 'arguments', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.MAP, 'environment', (TType.STRING,None,TType.STRING,None), None, ), # 4
    (5, TType.BOOL, 'clean_env', None, None, ), # 5
    (6, TType.BOOL, 'map_err_to_out', None, None, ), # 6
  )

  def __init__(self, inst_name=None, app_name=None, arguments=None, environment=None, clean_env=None, map_err_to_out=None,):
    self.inst_name = inst_name
    self.app_name = app_name
    self.arguments = arguments
    self.environment = environment
    self.clean_env = clean_env
    self.map_err_to_out = map_err_to_out

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.inst_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.app_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.arguments = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin()
          for _i11 in xrange(_size7):
            _key12 = iprot.readString();
            _val13 = iprot.readString();
            self.arguments[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.environment = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin()
          for _i18 in xrange(_size14):
            _key19 = iprot.readString();
            _val20 = iprot.readString();
            self.environment[_key19] = _val20
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.clean_env = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.map_err_to_out = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AppInstance')
    if self.inst_name is not None:
      oprot.writeFieldBegin('inst_name', TType.STRING, 1)
      oprot.writeString(self.inst_name)
      oprot.writeFieldEnd()
    if self.app_name is not None:
      oprot.writeFieldBegin('app_name', TType.STRING, 2)
      oprot.writeString(self.app_name)
      oprot.writeFieldEnd()
    if self.arguments is not None:
      oprot.writeFieldBegin('arguments', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.arguments))
      for kiter21,viter22 in self.arguments.items():
        oprot.writeString(kiter21)
        oprot.writeString(viter22)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.environment))
      for kiter23,viter24 in self.environment.items():
        oprot.writeString(kiter23)
        oprot.writeString(viter24)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clean_env is not None:
      oprot.writeFieldBegin('clean_env', TType.BOOL, 5)
      oprot.writeBool(self.clean_env)
      oprot.writeFieldEnd()
    if self.map_err_to_out is not None:
      oprot.writeFieldBegin('map_err_to_out', TType.BOOL, 6)
      oprot.writeBool(self.map_err_to_out)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.inst_name)
    value = (value * 31) ^ hash(self.app_name)
    value = (value * 31) ^ hash(self.arguments)
    value = (value * 31) ^ hash(self.environment)
    value = (value * 31) ^ hash(self.clean_env)
    value = (value * 31) ^ hash(self.map_err_to_out)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AppInfo:
  """
  Attributes:
   - app_name
   - inst_name
   - state
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'app_name', None, None, ), # 1
    (2, TType.STRING, 'inst_name', None, None, ), # 2
    (3, TType.STRING, 'state', None, None, ), # 3
  )

  def __init__(self, app_name=None, inst_name=None, state=None,):
    self.app_name = app_name
    self.inst_name = inst_name
    self.state = state

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.app_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.inst_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.state = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AppInfo')
    if self.app_name is not None:
      oprot.writeFieldBegin('app_name', TType.STRING, 1)
      oprot.writeString(self.app_name)
      oprot.writeFieldEnd()
    if self.inst_name is not None:
      oprot.writeFieldBegin('inst_name', TType.STRING, 2)
      oprot.writeString(self.inst_name)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRING, 3)
      oprot.writeString(self.state)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.app_name)
    value = (value * 31) ^ hash(self.inst_name)
    value = (value * 31) ^ hash(self.state)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Iface:
  """
  Attributes:
   - if_name
   - phy
   - mode
   - channel
   - start_ipaddress
   - ip_mapping
   - essid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'if_name', None, None, ), # 1
    (2, TType.STRING, 'phy', None, None, ), # 2
    (3, TType.STRING, 'mode', None, None, ), # 3
    (4, TType.I32, 'channel', None, None, ), # 4
    (5, TType.STRING, 'start_ipaddress', None, None, ), # 5
    (6, TType.MAP, 'ip_mapping', (TType.STRING,None,TType.STRING,None), None, ), # 6
    (7, TType.STRING, 'essid', None, None, ), # 7
  )

  def __init__(self, if_name=None, phy=None, mode=None, channel=None, start_ipaddress=None, ip_mapping=None, essid=None,):
    self.if_name = if_name
    self.phy = phy
    self.mode = mode
    self.channel = channel
    self.start_ipaddress = start_ipaddress
    self.ip_mapping = ip_mapping
    self.essid = essid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.if_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.phy = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mode = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.start_ipaddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.ip_mapping = {}
          (_ktype26, _vtype27, _size25 ) = iprot.readMapBegin()
          for _i29 in xrange(_size25):
            _key30 = iprot.readString();
            _val31 = iprot.readString();
            self.ip_mapping[_key30] = _val31
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.essid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Iface')
    if self.if_name is not None:
      oprot.writeFieldBegin('if_name', TType.STRING, 1)
      oprot.writeString(self.if_name)
      oprot.writeFieldEnd()
    if self.phy is not None:
      oprot.writeFieldBegin('phy', TType.STRING, 2)
      oprot.writeString(self.phy)
      oprot.writeFieldEnd()
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.STRING, 3)
      oprot.writeString(self.mode)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 4)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.start_ipaddress is not None:
      oprot.writeFieldBegin('start_ipaddress', TType.STRING, 5)
      oprot.writeString(self.start_ipaddress)
      oprot.writeFieldEnd()
    if self.ip_mapping is not None:
      oprot.writeFieldBegin('ip_mapping', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.ip_mapping))
      for kiter32,viter33 in self.ip_mapping.items():
        oprot.writeString(kiter32)
        oprot.writeString(viter33)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.essid is not None:
      oprot.writeFieldBegin('essid', TType.STRING, 7)
      oprot.writeString(self.essid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.if_name)
    value = (value * 31) ^ hash(self.phy)
    value = (value * 31) ^ hash(self.mode)
    value = (value * 31) ^ hash(self.channel)
    value = (value * 31) ^ hash(self.start_ipaddress)
    value = (value * 31) ^ hash(self.ip_mapping)
    value = (value * 31) ^ hash(self.essid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NodeInfo:
  """
  Attributes:
   - node_name
   - os
   - apps
   - ifaces
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node_name', None, None, ), # 1
    (2, TType.STRING, 'os', None, None, ), # 2
    (3, TType.LIST, 'apps', (TType.STRUCT,(AppInfo, AppInfo.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'ifaces', (TType.STRUCT,(Iface, Iface.thrift_spec)), None, ), # 4
  )

  def __init__(self, node_name=None, os=None, apps=None, ifaces=None,):
    self.node_name = node_name
    self.os = os
    self.apps = apps
    self.ifaces = ifaces

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.os = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.apps = []
          (_etype37, _size34) = iprot.readListBegin()
          for _i38 in xrange(_size34):
            _elem39 = AppInfo()
            _elem39.read(iprot)
            self.apps.append(_elem39)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.ifaces = []
          (_etype43, _size40) = iprot.readListBegin()
          for _i44 in xrange(_size40):
            _elem45 = Iface()
            _elem45.read(iprot)
            self.ifaces.append(_elem45)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NodeInfo')
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 1)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    if self.os is not None:
      oprot.writeFieldBegin('os', TType.STRING, 2)
      oprot.writeString(self.os)
      oprot.writeFieldEnd()
    if self.apps is not None:
      oprot.writeFieldBegin('apps', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.apps))
      for iter46 in self.apps:
        iter46.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ifaces is not None:
      oprot.writeFieldBegin('ifaces', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.ifaces))
      for iter47 in self.ifaces:
        iter47.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.node_name)
    value = (value * 31) ^ hash(self.os)
    value = (value * 31) ^ hash(self.apps)
    value = (value * 31) ^ hash(self.ifaces)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EventTrigger:
  """
  Attributes:
   - name
   - conditions
   - timer
   - enabled
   - periodic
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.MAP, 'conditions', (TType.STRING,None,TType.STRING,None), None, ), # 2
    (3, TType.I32, 'timer', None, None, ), # 3
    (4, TType.BOOL, 'enabled', None, None, ), # 4
    (5, TType.BOOL, 'periodic', None, None, ), # 5
  )

  def __init__(self, name=None, conditions=None, timer=None, enabled=None, periodic=None,):
    self.name = name
    self.conditions = conditions
    self.timer = timer
    self.enabled = enabled
    self.periodic = periodic

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.conditions = {}
          (_ktype49, _vtype50, _size48 ) = iprot.readMapBegin()
          for _i52 in xrange(_size48):
            _key53 = iprot.readString();
            _val54 = iprot.readString();
            self.conditions[_key53] = _val54
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timer = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.enabled = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.periodic = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EventTrigger')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.conditions is not None:
      oprot.writeFieldBegin('conditions', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.conditions))
      for kiter55,viter56 in self.conditions.items():
        oprot.writeString(kiter55)
        oprot.writeString(viter56)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.timer is not None:
      oprot.writeFieldBegin('timer', TType.I32, 3)
      oprot.writeI32(self.timer)
      oprot.writeFieldEnd()
    if self.enabled is not None:
      oprot.writeFieldBegin('enabled', TType.BOOL, 4)
      oprot.writeBool(self.enabled)
      oprot.writeFieldEnd()
    if self.periodic is not None:
      oprot.writeFieldBegin('periodic', TType.BOOL, 5)
      oprot.writeBool(self.periodic)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.conditions)
    value = (value * 31) ^ hash(self.timer)
    value = (value * 31) ^ hash(self.enabled)
    value = (value * 31) ^ hash(self.periodic)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateMsg:
  """
  Attributes:
   - child_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'child_type', None, None, ), # 1
  )

  def __init__(self, child_type=None,):
    self.child_type = child_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.child_type = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateMsg')
    if self.child_type is not None:
      oprot.writeFieldBegin('child_type', TType.STRING, 1)
      oprot.writeString(self.child_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.child_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigMsg:
  """
  Attributes:
   - ctype
   - field
   - field2
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'ctype', None, None, ), # 1
    (2, TType.STRING, 'field', None, None, ), # 2
    (3, TType.STRING, 'field2', None, None, ), # 3
  )

  def __init__(self, ctype=None, field=None, field2=None,):
    self.ctype = ctype
    self.field = field
    self.field2 = field2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.ctype = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.field2 = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigMsg')
    if self.ctype is not None:
      oprot.writeFieldBegin('ctype', TType.I32, 1)
      oprot.writeI32(self.ctype)
      oprot.writeFieldEnd()
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 2)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    if self.field2 is not None:
      oprot.writeFieldBegin('field2', TType.STRING, 3)
      oprot.writeString(self.field2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ctype)
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.field2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RequestMsg:
  """
  Attributes:
   - field
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'field', None, None, ), # 1
  )

  def __init__(self, field=None,):
    self.field = field

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RequestMsg')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 1)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReleaseMsg:
  """
  Attributes:
   - field
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'field', None, None, ), # 1
  )

  def __init__(self, field=None,):
    self.field = field

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReleaseMsg')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 1)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.field is None:
      raise TProtocol.TProtocolException(message='Required field field is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InformMsg:
  """
  Attributes:
   - itype
   - cid
   - field
   - nodeinfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'itype', None, None, ), # 1
    (2, TType.I32, 'cid', None, None, ), # 2
    (3, TType.STRING, 'field', None, None, ), # 3
    (4, TType.STRUCT, 'nodeinfo', (NodeInfo, NodeInfo.thrift_spec), None, ), # 4
  )

  def __init__(self, itype=None, cid=None, field=None, nodeinfo=None,):
    self.itype = itype
    self.cid = cid
    self.field = field
    self.nodeinfo = nodeinfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.itype = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.nodeinfo = NodeInfo()
          self.nodeinfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InformMsg')
    if self.itype is not None:
      oprot.writeFieldBegin('itype', TType.I32, 1)
      oprot.writeI32(self.itype)
      oprot.writeFieldEnd()
    if self.cid is not None:
      oprot.writeFieldBegin('cid', TType.I32, 2)
      oprot.writeI32(self.cid)
      oprot.writeFieldEnd()
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 3)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    if self.nodeinfo is not None:
      oprot.writeFieldBegin('nodeinfo', TType.STRUCT, 4)
      self.nodeinfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.itype)
    value = (value * 31) ^ hash(self.cid)
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.nodeinfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MsgHeader:
  """
  Attributes:
   - version
   - mtype
   - msg_id
   - source
   - ts
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.I32, 'mtype', None, None, ), # 2
    (3, TType.I32, 'msg_id', None, None, ), # 3
    (4, TType.STRING, 'source', None, None, ), # 4
    (5, TType.DOUBLE, 'ts', None, None, ), # 5
  )

  def __init__(self, version=None, mtype=None, msg_id=None, source=None, ts=None,):
    self.version = version
    self.mtype = mtype
    self.msg_id = msg_id
    self.source = source
    self.ts = ts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.mtype = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.msg_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.ts = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MsgHeader')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.mtype is not None:
      oprot.writeFieldBegin('mtype', TType.I32, 2)
      oprot.writeI32(self.mtype)
      oprot.writeFieldEnd()
    if self.msg_id is not None:
      oprot.writeFieldBegin('msg_id', TType.I32, 3)
      oprot.writeI32(self.msg_id)
      oprot.writeFieldEnd()
    if self.source is not None:
      oprot.writeFieldBegin('source', TType.STRING, 4)
      oprot.writeString(self.source)
      oprot.writeFieldEnd()
    if self.ts is not None:
      oprot.writeFieldBegin('ts', TType.DOUBLE, 5)
      oprot.writeDouble(self.ts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.mtype)
    value = (value * 31) ^ hash(self.msg_id)
    value = (value * 31) ^ hash(self.source)
    value = (value * 31) ^ hash(self.ts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
